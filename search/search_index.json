{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FAIR-biomed a browser extension for accessing open biomed data FAIR -biomed helps to access open biomedical data resources from any web page. About Vasts amounts of biomedical data are stored in open databases and knowledge-bases. Data in these resources are intended to be findable, accessible, interoperable, and reusable ( FAIR ). However, the data is distributed across many resources and integrating relevant parts within a specific project can be a challenge. FAIR-biomed brings open data resources directly to specific research situations. Consider, for example, reading a report in the browser. With FAIR-biomed, you can access additional information on any part of the report without leaving the page. To make use of the extension, first highlight some text, for example, a gene name. Press Ctr+Shift+Z on the keyboard (alternatively right-click > FAIR-biomed search with the mouse). A new box should appear prompting you to choose a data source to query. Clicking on one of the options triggers a query to the corresponding data service and displays a summary of results. Search results provide summaries of the data resource, details of how the data query was executed, and a link to further data. Data sources The FAIR-biomed app is composed of core components and a library of plugins. Each of the plugins provides access to a data resource and a specific query type. The current plugin library provides access to a varied set of data sources. Data source Plugins ClinGen Allele registry EBI Identifiers, ontology, GWAS, and chemical data Europe PMC Literature ExAC Genomic variant annotation Genomics England PanelApp HGNC Gene nomenclature IMPC Mouse model phenotypes JASPAR Transcription factor binding profiles LNCipedia non-coding RNAs MARRVEL Disease associations, gene expression NCBI Literature, gene summaries, significance of genetic variation Reactome Pathways STRING Protein interaction networks UCSC Genomic regions Uniprot Knowledgebase Wikimedia Encyclopaedia and dictionary Practical guide Installation The extension is available from the chrome web store . Select the extension in the web store, click Add to chrome , and read the information boxes. Once installed, highlight text on a web page and press Ctrl+Shift+Z to perform searches. To install the FAIR-biomed extension manually using code from this repository, see the developer documentation Local URLs The extension is automatically active on all pages that you accesss via urls starting with 'http' or 'https'. You can also use the extension with reports stored on your own computer, but this functionality is disabled by default by the chrome browser. To use this feature, you must enable it manually. Select Tools > Extensions from the chrome menus; a new tab should appear listing all your installed extensions Find FAIR-biomed and click Details ; the view should change and display more details on the extension Scroll down to the setting Allow access to file URLs and turn on the switch. Options The extension has a dedicated page where you can tune which data sources you would like to use. Find the FAIR-biomed icon on the browser toolbar (it's usually on the top-right). Click on the icon. A popup should appear. Click on the 'cogs' icon to open the Options page. Privacy Once installed, the extension records a small amount of information to personalize its behavior to each user. See the privacy policy . In the news FAIR-biomed was featured in the news! Using Europe PMC RESTful APIs , August 20 2019. Notes and References The idea of augmenting web pages with additional information has a long history. Reflect was an early implementation of a browser extension aimed at biomedical research. This extension sent a whole web-page to a server for annotation. Dynamic linking outlined an idea to infer links to specialist sources by scanning the context of web pages. GIX described an extension for retrieving information on gene products. Get involved Feedback and contributions are welcome. Please raise an issue in the github repository. To incorporate a new data resource or plugin, read how you can contribute .","title":"Home"},{"location":"#about","text":"Vasts amounts of biomedical data are stored in open databases and knowledge-bases. Data in these resources are intended to be findable, accessible, interoperable, and reusable ( FAIR ). However, the data is distributed across many resources and integrating relevant parts within a specific project can be a challenge. FAIR-biomed brings open data resources directly to specific research situations. Consider, for example, reading a report in the browser. With FAIR-biomed, you can access additional information on any part of the report without leaving the page. To make use of the extension, first highlight some text, for example, a gene name. Press Ctr+Shift+Z on the keyboard (alternatively right-click > FAIR-biomed search with the mouse). A new box should appear prompting you to choose a data source to query. Clicking on one of the options triggers a query to the corresponding data service and displays a summary of results. Search results provide summaries of the data resource, details of how the data query was executed, and a link to further data.","title":"About"},{"location":"#data-sources","text":"The FAIR-biomed app is composed of core components and a library of plugins. Each of the plugins provides access to a data resource and a specific query type. The current plugin library provides access to a varied set of data sources. Data source Plugins ClinGen Allele registry EBI Identifiers, ontology, GWAS, and chemical data Europe PMC Literature ExAC Genomic variant annotation Genomics England PanelApp HGNC Gene nomenclature IMPC Mouse model phenotypes JASPAR Transcription factor binding profiles LNCipedia non-coding RNAs MARRVEL Disease associations, gene expression NCBI Literature, gene summaries, significance of genetic variation Reactome Pathways STRING Protein interaction networks UCSC Genomic regions Uniprot Knowledgebase Wikimedia Encyclopaedia and dictionary","title":"Data sources"},{"location":"#practical-guide","text":"","title":"Practical guide"},{"location":"#installation","text":"The extension is available from the chrome web store . Select the extension in the web store, click Add to chrome , and read the information boxes. Once installed, highlight text on a web page and press Ctrl+Shift+Z to perform searches. To install the FAIR-biomed extension manually using code from this repository, see the developer documentation","title":"Installation"},{"location":"#local-urls","text":"The extension is automatically active on all pages that you accesss via urls starting with 'http' or 'https'. You can also use the extension with reports stored on your own computer, but this functionality is disabled by default by the chrome browser. To use this feature, you must enable it manually. Select Tools > Extensions from the chrome menus; a new tab should appear listing all your installed extensions Find FAIR-biomed and click Details ; the view should change and display more details on the extension Scroll down to the setting Allow access to file URLs and turn on the switch.","title":"Local URLs"},{"location":"#options","text":"The extension has a dedicated page where you can tune which data sources you would like to use. Find the FAIR-biomed icon on the browser toolbar (it's usually on the top-right). Click on the icon. A popup should appear. Click on the 'cogs' icon to open the Options page.","title":"Options"},{"location":"#privacy","text":"Once installed, the extension records a small amount of information to personalize its behavior to each user. See the privacy policy .","title":"Privacy"},{"location":"#in-the-news","text":"FAIR-biomed was featured in the news! Using Europe PMC RESTful APIs , August 20 2019.","title":"In the news"},{"location":"#notes-and-references","text":"The idea of augmenting web pages with additional information has a long history. Reflect was an early implementation of a browser extension aimed at biomedical research. This extension sent a whole web-page to a server for annotation. Dynamic linking outlined an idea to infer links to specialist sources by scanning the context of web pages. GIX described an extension for retrieving information on gene products.","title":"Notes and References"},{"location":"#get-involved","text":"Feedback and contributions are welcome. Please raise an issue in the github repository. To incorporate a new data resource or plugin, read how you can contribute .","title":"Get involved"},{"location":"contributing/","text":"Contributing Contributions to the FAIR-biomed browser extension are welcome. Plugins Plugins are meant to be lightweight components that link between the core app and science APIs. Short . Keep computations within each plugin to a minimum for performance and readability. Simple . Use pure javascript without any external libraries. Small . Use small-sized files for the logo and information resources. Self-contained . Restrict each function to process its inputs only; calls for outside resources (e.g. ajax) will not be considered. Complete . Provide all relevant information, especially a description of the data source with appropriate attribution and examples of queries that the plugin should be able to claim and process. To incorporate a new plugin into the main extension: Create an issue in the parent repo with a proposal for a new plugin. This is not a strict requirement, but is a means to gather suggestions and ideas. Fork the parent repo and develop a new plugin within that fork. Make sure the plugin passes unit tests and contains appropriate tests of its own. Check that it can be incorporated into the main library, and produces desired output in the browser. Send a pull request to the parent repo. Code structure The repo source code is organized in distinct parts. See the code structure . App Updates/improvements to the main app are also welcome. These are likely not to be as standardized as plugins and must be consistent with the existing plugin library. Please use issues to discuss proposed changes.","title":"Contribute"},{"location":"contributing/#contributing","text":"Contributions to the FAIR-biomed browser extension are welcome.","title":"Contributing"},{"location":"contributing/#plugins","text":"Plugins are meant to be lightweight components that link between the core app and science APIs. Short . Keep computations within each plugin to a minimum for performance and readability. Simple . Use pure javascript without any external libraries. Small . Use small-sized files for the logo and information resources. Self-contained . Restrict each function to process its inputs only; calls for outside resources (e.g. ajax) will not be considered. Complete . Provide all relevant information, especially a description of the data source with appropriate attribution and examples of queries that the plugin should be able to claim and process. To incorporate a new plugin into the main extension: Create an issue in the parent repo with a proposal for a new plugin. This is not a strict requirement, but is a means to gather suggestions and ideas. Fork the parent repo and develop a new plugin within that fork. Make sure the plugin passes unit tests and contains appropriate tests of its own. Check that it can be incorporated into the main library, and produces desired output in the browser. Send a pull request to the parent repo.","title":"Plugins"},{"location":"contributing/#code-structure","text":"The repo source code is organized in distinct parts. See the code structure .","title":"Code structure"},{"location":"contributing/#app","text":"Updates/improvements to the main app are also welcome. These are likely not to be as standardized as plugins and must be consistent with the existing plugin library. Please use issues to discuss proposed changes.","title":"App"},{"location":"install/","text":"Installation Clone or fork If you would only like to experiment with the repo, clone it into a local directory. If you would like to develop new components and merge with the parent repo, make a fork first and then clone the forked version. (Also see the guide for contributors ). Install dependencies After you have a local copy of the source code, the next steps are to install all dependencies and then building the application. First, install all dependencies using the node package manager. npm install This step may take ime as several dependencies are installed in a new folder node_modules . Test The next stage in the installation process is testing. Although testing is sometimes an optional step during an installation procedure, that is not the case for FAIR-biomed. This is because the testing stage evaluates the types of plugins that are available and in working condition. Only properly functioning plugins are made available for the next build stage. Thus, run the entire test suite. npm run test This should display a positive message at the end. Build the extension Finally, build the app. npm run build This command creates a a directory dist and populates it with files required for the extension to work in the browser. If you are aiming to develop new components, look into package.json to examine the steps to generate the core of the extension as well as the plugin library. The individual steps will be useful during development. Load into the browser After these build steps, add the extension to your browser. Under the customize menu (vertical dots beside the navigation bar), select More tools and Extensions . A screen should appear. Turn on developer mode (switch on top-right), then click Load unpacked . In the popup window, select the location of the dist folder.","title":"Install"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#clone-or-fork","text":"If you would only like to experiment with the repo, clone it into a local directory. If you would like to develop new components and merge with the parent repo, make a fork first and then clone the forked version. (Also see the guide for contributors ).","title":"Clone or fork"},{"location":"install/#install-dependencies","text":"After you have a local copy of the source code, the next steps are to install all dependencies and then building the application. First, install all dependencies using the node package manager. npm install This step may take ime as several dependencies are installed in a new folder node_modules .","title":"Install dependencies"},{"location":"install/#test","text":"The next stage in the installation process is testing. Although testing is sometimes an optional step during an installation procedure, that is not the case for FAIR-biomed. This is because the testing stage evaluates the types of plugins that are available and in working condition. Only properly functioning plugins are made available for the next build stage. Thus, run the entire test suite. npm run test This should display a positive message at the end.","title":"Test"},{"location":"install/#build-the-extension","text":"Finally, build the app. npm run build This command creates a a directory dist and populates it with files required for the extension to work in the browser. If you are aiming to develop new components, look into package.json to examine the steps to generate the core of the extension as well as the plugin library. The individual steps will be useful during development.","title":"Build the extension"},{"location":"install/#load-into-the-browser","text":"After these build steps, add the extension to your browser. Under the customize menu (vertical dots beside the navigation bar), select More tools and Extensions . A screen should appear. Turn on developer mode (switch on top-right), then click Load unpacked . In the popup window, select the location of the dist folder.","title":"Load into the browser"},{"location":"plugins/","text":"Plugins Plugin definitions are located in subdirectories of library . For example, plugins accessing data from the Wikimedia foundation are located in library/wikimedia . To create a new plugin, create new subdirectory with the name of your data source. Plugins as modules Plugin definitions consist of javascript files (extension .js ) written as modules. Each module is required to define a number of components. Static fields: id - string, a unique identifier for the plugin. This is never seen by the end user, but it is used by the core app. title - string, a short heading of the plugin. subtitle - string, a short description. tags - array of strings, keywords associated with the plugin. logo - string, name for a logo image file (svg, png, jpg) info - string, name for a text/html file containing a description of the data source Functions: claim(query) - should return a number [0,1] signaling to what extent the plugin can provide useful information given a query string. Higher numbers give the plugin a higher ranking in the results list. url(query, index) - should return a url for an API call for the given query string. An integer index can be used if plugins require multiple round-trips to the API (see wikipedia plugin for an example) process(response, index) - should transform data obtained from an API call into a simple object that can be displayed within the extension's output window. An integer index can be used if plugins require multiple round-trips to the API (see wikipedia for an example). extenal(query) - should construct a url to a human-readable page holding more information pertaining to a query. Note that a plugin directory can contain more than one plugin definition file. However, each file can define only on plugin. TO DO - describe output for process() Auxiliary files Plugins require auxiliary data components. Image files (logo) and text files (data source description) must be placed within the same directory as the plugin definition files. Testing Testing is carried out at two levels. The first is programmatic testing via unit tests. npm run test-plugin library/wikimedia The test-plugin script executes a small number of tests on each plugin, for example checking that each plugin contains the required fields and functions. Additional, plugin-specific, tests can be included into the testing framework by adding test files in the plugin folders. These test files must be named as test-[plugin-name].js , see the folder with the wikimedia plugins for an example. The second level of testing focuses on getting the plugin to display proper information in the browser. Build a new library incorporating the new plugin. To build the entire library containing all plugins, use the same command as above, npm run build-lib . However, it is also possible to build a library containing just the relevant plugin. npm run build-lib library/wikimedia The build script also performs some checks and signals development hints. After a successful library build, reload the extension in the browser, navigate to a relevant webpage (or refresh an existing tab/window), and manually check whether relevant queries provide the expected output. Note, this manual process is sufficient for simple plugins that do not perform much processing on their API's output. In cases where more extensive processing is required, it is possible to set up dedicated unit tests for each plugin.","title":"Plugins"},{"location":"plugins/#plugins","text":"Plugin definitions are located in subdirectories of library . For example, plugins accessing data from the Wikimedia foundation are located in library/wikimedia . To create a new plugin, create new subdirectory with the name of your data source.","title":"Plugins"},{"location":"plugins/#plugins-as-modules","text":"Plugin definitions consist of javascript files (extension .js ) written as modules. Each module is required to define a number of components. Static fields: id - string, a unique identifier for the plugin. This is never seen by the end user, but it is used by the core app. title - string, a short heading of the plugin. subtitle - string, a short description. tags - array of strings, keywords associated with the plugin. logo - string, name for a logo image file (svg, png, jpg) info - string, name for a text/html file containing a description of the data source Functions: claim(query) - should return a number [0,1] signaling to what extent the plugin can provide useful information given a query string. Higher numbers give the plugin a higher ranking in the results list. url(query, index) - should return a url for an API call for the given query string. An integer index can be used if plugins require multiple round-trips to the API (see wikipedia plugin for an example) process(response, index) - should transform data obtained from an API call into a simple object that can be displayed within the extension's output window. An integer index can be used if plugins require multiple round-trips to the API (see wikipedia for an example). extenal(query) - should construct a url to a human-readable page holding more information pertaining to a query. Note that a plugin directory can contain more than one plugin definition file. However, each file can define only on plugin. TO DO - describe output for process()","title":"Plugins as modules"},{"location":"plugins/#auxiliary-files","text":"Plugins require auxiliary data components. Image files (logo) and text files (data source description) must be placed within the same directory as the plugin definition files.","title":"Auxiliary files"},{"location":"plugins/#testing","text":"Testing is carried out at two levels. The first is programmatic testing via unit tests. npm run test-plugin library/wikimedia The test-plugin script executes a small number of tests on each plugin, for example checking that each plugin contains the required fields and functions. Additional, plugin-specific, tests can be included into the testing framework by adding test files in the plugin folders. These test files must be named as test-[plugin-name].js , see the folder with the wikimedia plugins for an example. The second level of testing focuses on getting the plugin to display proper information in the browser. Build a new library incorporating the new plugin. To build the entire library containing all plugins, use the same command as above, npm run build-lib . However, it is also possible to build a library containing just the relevant plugin. npm run build-lib library/wikimedia The build script also performs some checks and signals development hints. After a successful library build, reload the extension in the browser, navigate to a relevant webpage (or refresh an existing tab/window), and manually check whether relevant queries provide the expected output. Note, this manual process is sufficient for simple plugins that do not perform much processing on their API's output. In cases where more extensive processing is required, it is possible to set up dedicated unit tests for each plugin.","title":"Testing"},{"location":"privacy/","text":"Privacy The extension records a small amount of information to personalize its behavior to each user. This data pertains to which plugins are active (see previous section on Options), how many times each plugin is used, and whether each plugin is rated or bookmarked. This information remains on each user's computer and can be adjusted through the Options page. This information is not shared with outside services. The extension only processes query text that appears in its search box. The extension does not automatically scan entire documents. The extension does not record performed searches. Note, however, that the extension sends queries to external APIs. Some of these services may record activity (for example, to demonstrate their relevance to the science community). See the privacy policies of those services for details. When installing the extension from the chrome web store, Google collects some user information. See their privacy policy for details.","title":"Privacy"},{"location":"privacy/#privacy","text":"The extension records a small amount of information to personalize its behavior to each user. This data pertains to which plugins are active (see previous section on Options), how many times each plugin is used, and whether each plugin is rated or bookmarked. This information remains on each user's computer and can be adjusted through the Options page. This information is not shared with outside services. The extension only processes query text that appears in its search box. The extension does not automatically scan entire documents. The extension does not record performed searches. Note, however, that the extension sends queries to external APIs. Some of these services may record activity (for example, to demonstrate their relevance to the science community). See the privacy policies of those services for details. When installing the extension from the chrome web store, Google collects some user information. See their privacy policy for details.","title":"Privacy"},{"location":"structure/","text":"Code structure The repo source code is organized in distinct parts. documentation - docs plugin library - library core extension - src/app build scripts - src/build tests - test Other directories are created during installation and development. dependencies - node_modules browser extension - dist In order to create or to maintain a plugin, the parts of interest are the library and the test components. You should be able to install the extension and create a new plugin without accessing the other parts.","title":"Code structure"},{"location":"structure/#code-structure","text":"The repo source code is organized in distinct parts. documentation - docs plugin library - library core extension - src/app build scripts - src/build tests - test Other directories are created during installation and development. dependencies - node_modules browser extension - dist In order to create or to maintain a plugin, the parts of interest are the library and the test components. You should be able to install the extension and create a new plugin without accessing the other parts.","title":"Code structure"},{"location":"img/","text":"README for docs/img Images with file names starting with 'ChromeWebStore' were downloaded from the chrome webstore branding guidelines page . They are repdoduced in this repo only to serve the main README file in the repo root.","title":"README for docs/img"},{"location":"img/#readme-for-docsimg","text":"Images with file names starting with 'ChromeWebStore' were downloaded from the chrome webstore branding guidelines page . They are repdoduced in this repo only to serve the main README file in the repo root.","title":"README for docs/img"}]}